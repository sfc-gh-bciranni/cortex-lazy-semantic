from typing import (
    Dict, Iterable, Union, Optional, List, Set, Tuple, 
    get_origin, get_args, Any, Literal
)
from collections.abc import Iterable as IterableABC
from pydantic import TypeAdapter
from copy import deepcopy
from .semantic_model import SemanticModel

import json

def is_type_match(obj, type_hint):
    """
    Check if the object matches the type hint.

    Args:
        obj: The object to check.
        type_hint: The type hint to check against.

    Returns:
        True if the object matches the type hint, False otherwise.
    """
    # Handle Any type
    if type_hint is Any:
        return True
        
    # Get the origin type
    origin = get_origin(type_hint)
    
    # Handle Union types (including Optional)
    if origin is Union:
        return any(is_type_match(obj, arg) for arg in get_args(type_hint))
        
    # Handle Literal types
    if origin is Literal:
        return obj in get_args(type_hint)
        
    # If no origin, it's a basic type
    if origin is None:
        return isinstance(obj, type_hint)
        
    # Check if object matches the origin type
    if not isinstance(obj, origin):
        return False
        
    args = get_args(type_hint)
    
    # Handle different container types
    if origin is list or origin is List or origin is IterableABC:
        return all(is_type_match(item, args[0]) for item in obj)
        
    if origin is dict or origin is Dict:
        return all(
            is_type_match(k, args[0]) and is_type_match(v, args[1])
            for k, v in obj.items()
        )
        
    if origin is set or origin is Set:
        return all(is_type_match(item, args[0]) for item in obj)
        
    if origin is tuple or origin is Tuple:
        if len(args) == 2 and args[1] is ...:
            # Handle Tuple[int, ...] case
            return all(is_type_match(item, args[0]) for item in obj)
        # Handle Tuple[int, str, bool] case
        return (len(obj) == len(args) and 
                all(is_type_match(item, arg) for item, arg in zip(obj, args)))
    
    return True

# Function to recursively inline $defs
def flatten_schema(schema: Dict):
    """Recursively replaces all $ref references with their definitions."""
    if "$defs" not in schema:
        return schema  # Nothing to flatten

    flat_schema = deepcopy(schema)
    definitions = flat_schema.pop("$defs")

    def resolve_refs(obj):
        """Recursively replace $ref with inline definitions.
        This is a workaround to handle the fact that the JSON Schema
        generated by Pydantic is not valid for Cortex.

        Args:
            obj: The object to replace $ref with inline definitions.

        Returns:
            The object with $ref replaced with inline definitions.
        """
        if isinstance(obj, dict):
            if "$ref" in obj:
                ref_path = obj["$ref"].split("/")[-1]  # Get the key from $defs
                return resolve_refs(definitions.get(ref_path, {}))
            return {k: resolve_refs(v) for k, v in obj.items()}
        elif isinstance(obj, list):
            return [resolve_refs(i) for i in obj]
        return obj
    
    def replace_any_of(obj):
        """Replace anyOf with the first item.
        This is a workaround to handle the fact that the JSON Schema
        generated by Pydantic is not valid for Cortex.

        Args:
            obj: The object to replace anyOf with the first item.

        Returns:
            The object with anyOf replaced with the first item.
        """
        if isinstance(obj, dict):
            if "anyOf" in obj:
                any_of = obj["anyOf"]
                if is_type_match(any_of, Iterable[Dict[str, str]]):
                    if len(any_of) >= 1:
                        return any_of[0]
                else:
                    return replace_any_of(any_of[0])
            return {k: replace_any_of(v) for k, v in obj.items()}
        elif isinstance(obj, list):
            return [replace_any_of(i) for i in obj]
        return obj
    
    return replace_any_of(resolve_refs(flat_schema))

# Generate the JSON Schema
def get_semantic_model_spec_schema():
    """
    Generate the JSON Schema for the SemanticModel.

    Returns:
        The JSON Schema for the SemanticModel.
    """
    # Get the model's JSON Schema
    schema = TypeAdapter(SemanticModel).json_schema()
    # Flatten the schema
    flattened_schema = flatten_schema(schema)
    # Format the schema for Cortex
    json_format = {
        'type': 'json',
        'schema': flattened_schema
    }
    return json_format